//var require: Require;
require && require.config({ paths: { 'vs': 'vendor/monaco/min/vs' } });

declare namespace ts {
    // (JW: I created this to help reference the hidden typescript worker via the proxy service, which may provide some helpful insights)
    export interface IMonacoTypeScriptServiceProxy {
        _getModel(uri: string): Promise<{ _eol: string, _lineStarts: any, _Lines: string[], length: number, _uri: monaco.Uri, _versionId: number }>;
        getCompilationSettings(): Promise<CompilerOptions>;
        getCompilerOptionsDiagnostics(): Promise<Diagnostic[]>;
        getCompletionEntryDetails(uri: string, position: number, name: string, formatOptions: FormatCodeOptions | FormatCodeSettings | undefined, source: string | undefined, preferences: UserPreferences | undefined): Promise<CompletionEntryDetails | undefined>;
        getCompletionsAtPosition(uri: string, position: number, options: GetCompletionsAtPositionOptions | undefined): Promise<WithMetadata<CompletionInfo> | undefined>;
        getCurrentDirectory(): Promise<string>;
        getDefaultLibFileName(options: CompilerOptions): Promise<string>;
        getDefinitionAtPosition(uri: string, position: number): Promise<ReadonlyArray<DefinitionInfo> | undefined>;
        getEmitOutput(uri: string, emitOnlyDtsFiles?: boolean): Promise<EmitOutput>;
        getFormattingEditsAfterKeystroke(uri: string, position: number, key: string, options: FormatCodeOptions | FormatCodeSettings): Promise<TextChange[]>;
        getFormattingEditsForDocument(uri: string, options: FormatCodeOptions | FormatCodeSettings): Promise<TextChange[]>;
        getFormattingEditsForRange(uri: string, start: number, end: number, options: FormatCodeOptions | FormatCodeSettings): Promise<TextChange[]>;
        getNavigationBarItems(uri: string): Promise<NavigationBarItem[]>;
        getOccurrencesAtPosition(uri: string, position: number): Promise<ReadonlyArray<ReferenceEntry> | undefined>;
        getQuickInfoAtPosition(uri: string, position: number): Promise<QuickInfo | undefined>;
        getReferencesAtPosition(uri: string, position: number): Promise<ReferenceEntry[] | undefined>;
        getScriptFileNames(): Promise<string[]>;
        getScriptKind(uri: string): Promise<ScriptKind>;
        getScriptSnapshot(uri: string): Promise<IScriptSnapshot | undefined>;
        getScriptVersion(uri: string): Promise<string>;
        /** The first time this is called, it will return global diagnostics (no location). */
        getSemanticDiagnostics(uri: string): Promise<Diagnostic[]>;
        getSignatureHelpItems(uri: string, position: number, options: SignatureHelpItemsOptions | undefined): Promise<SignatureHelpItems | undefined>;
        getSyntacticDiagnostics(uri: string): Promise<DiagnosticWithLocation[]>;
        isDefaultLibFileName(uri: string): Promise<boolean>;
    }
}

interface INode { }
interface ISubflow { }
interface IGroup { }

type showeditor = (options: object) => void;

declare namespace RED {
    export var settings: any;
    export namespace editor {
        export var init: Function;
        export var edit: (node: INode) => void;
        export var editConfig: (name: string, type: string, id: string, prefix: string) => void;
        export var editSubflow: (subflow: ISubflow) => void;
        export var editGroup: (group: IGroup) => void;
        export var editJavaScript: showeditor;
        export var editExpression: showeditor;
        export var editJSON: showeditor;
        export var editMarkdown: showeditor;
        export var editText: showeditor;
        export var editBuffer: showeditor;
        export var buildEditForm: (container: any, formId: string, type: string, ns: any, node: any) => HTMLElement;
        export var validateNode: (node: INode) => boolean;
        export var updateNodeProperties: (node: INode, outputMap: any) => any[]; // TODO: only exposed for edit-undo

        export var showIconPicker: (container: any, backgroundColor: any, iconPath: string, faOnly: boolean, done: boolean) => void;

        /**
         * Show a type editor.
         * @param {string} type - the type to display
         * @param {object} options - options for the editor
         * @function
         * @memberof RED.editor
         */
        export var showTypeEditor: (type: string, options: object) => void;

        /**
         * Register a type editor.
         * @param {string} type - the type name
         * @param {object} definition - the editor definition
         * @function
         * @memberof RED.editor
         */
        export var registerTypeEditor: (type: string, definition: string) => void;

        /**
         * Create a editor ui component
         * @param {object} options - the editor options
         * @function
         * @memberof RED.editor
         */
        export var createEditor: (options: object) => HTMLElement;
    }
}

/**
 * An implementation of the Monaco editor
 * @namespace RED.editor.monaco
 */
namespace RED.editor {
    var USE_MONACO: boolean;
    var monacoThemes = ["vs", "vs-dark", "hc-black"];

    export class Monaco {
        static editorSettings: any;
        static editorOptions: any;

        /** Load and initialize the Monaco editor system. 
         * Note: This function returns a Promise object. Don't create editors until it resolves.
         */
        static async initialize() {
            if (!require)
                throw "'RequireJS' is not loaded.";

            //if (!ts)
            //    throw "'ts' TypeScript service namespace reference is required - is the 'ace/mode/typescript/typescriptServices.js' file loaded?.";

            console.log("initialize(): Creating the Monaco editor promise ...");

            return new Promise<any>((resolve, reject) => {
                console.log("initialize(): Loading the Monaco editor ...");

                require(['vs/editor/editor.main'], (main: typeof monaco) => {

                    if (!main) {
                        var msg = "initialize(): Failed loading 'vs/editor/editor.main'. Make sure 'public\\vendor\\monaco\\min\vs' exists.";
                        (console.error || console.log)(msg);
                        throw msg;
                    }

                    this._configure();

                    resolve();

                }, (msg: RequireError) => {
                    console.log("initialize(): Failed loading the Monaco editor");
                    reject("Failed loading 'FlowScript/ace/ace_ts_editor_main' module: " + msg + "\r\n" + ((<any>msg).stack || ""));
                });
            });
        }

        private static _configure() {
            var editorOptions = this.editorOptions;

            if (editorOptions.theme) {
                if (!monacoThemes.includes(editorOptions.theme)) {
                    var customTheme = 'vendor/monaco/min/vs/theme/' + editorOptions.theme + '.json';
                    console.log("initMonaco->Attempting to load custom theme: ", customTheme);
                    $.get(customTheme, function (theme) {
                        monacoThemes.push(editorOptions.theme);//add to list of loaded themes
                        console.log("initMonaco->got custom theme: ", theme);
                        if ((theme.rules && Array.isArray(theme.rules)) || theme.colors) {
                            monaco.editor.defineTheme(editorOptions.theme, theme);
                            monaco.editor.setTheme(editorOptions.theme);
                        } else {
                            console.log("initMonaco->custom monaco theme doent contain 'rules' or 'colors'")
                        }
                    });
                } else {
                    console.log("initMonaco->No need to load custom theme: ", editorOptions.theme);
                }

            }

            interface IRange {
                startLineNumber: number;
                endLineNumber: number;
                startColumn: number;
                endColumn: number;
            }

            function createDependencyProposals(range: IRange) {
                return [
                    {
                        label: 'forloop',
                        kind: monaco.languages.CompletionItemKind.Snippet,
                        documentation: "for loop",
                        insertText: 'for (let ${1:index} = 0; ${1:index} < ${2:array}.length; ${1:index}++) {\n\tconst element = ${2:array}[${1:index}];\n\t${3}\n}',
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        range: range
                    },
                    {
                        label: 'warn (node.warn)',
                        kind: monaco.languages.CompletionItemKind.Snippet,
                        documentation: "send a warning to the debug side bar",
                        insertText: 'node.warn(${1:"my warning"});',
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        range: range
                    },
                    {
                        label: 'error (node.error)',
                        kind: monaco.languages.CompletionItemKind.Snippet,
                        documentation: "send an error to the debug side bar",
                        insertText: 'node.error(${1:err}, ${2:msg});',
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        range: range
                    },
                    {
                        label: 'send message',
                        kind: monaco.languages.CompletionItemKind.Snippet,
                        documentation: "async send a msg to the next node",
                        insertText: 'node.send(${2:msg});',
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        range: range
                    },
                    {
                        label: 'send messages',
                        kind: monaco.languages.CompletionItemKind.Snippet,
                        documentation: "send more than 1 message out of multiple outputs",
                        insertText: 'var ${1:msg1} = {payload:${2:1}};\nvar ${3:msg2} = {payload:${4:2}};\nnode.send([${1:msg1}, ${3:msg2}]);',
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        range: range
                    },
                    {
                        label: 'send messages2',
                        kind: monaco.languages.CompletionItemKind.Snippet,
                        documentation: "send more than 1 message out of 1 output",
                        insertText: 'var ${1:msg1} = {payload:${2:1}};\nvar ${3:msg2} = {payload:${4:2}};\nnode.send([[${1:msg1}, ${3:msg2}]]);',
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        range: range
                    },
                    {
                        label: 'status (node.status)',
                        kind: monaco.languages.CompletionItemKind.Snippet,
                        documentation: "Set the status icon and text underneath the function node",
                        insertText: 'node.status({fill:"${1:red}",shape:"${2:ring}",text:"${3:error}"});',
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        range: range
                    }
                ];
            }

            monaco.languages.registerCompletionItemProvider('javascript', {
                provideCompletionItems: function (model, position) {
                    var word = model.getWordUntilPosition(position);
                    var range = <IRange>{
                        startLineNumber: position.lineNumber,
                        endLineNumber: position.lineNumber,
                        startColumn: word.startColumn,
                        endColumn: word.endColumn
                    };
                    return {
                        suggestions: createDependencyProposals(range)
                    };
                }
            });

            //TODO: split out to file. also add Buffer and other objects
            var nodeLib = ' \
                interface _msg { \
                    _msgid: number; \
                    payload: object, \
                    topic: string \
                } \
                var msg: _msg; \
                declare class node { \
                    /** send a message to next node */ \
                    static send(msg:Object, clone:Boolean=true); \
                    /** Inform runtime this instance has completed its operation */ \
                    static done(); \
                    /** Send an error to the debug side bar */ \
                    static error(err:String|Error, msg:Object=null); \
                    /** Send an warning to the debug side bar */ \
                    static warn(warning:String|Object); \
                    /** Set the status icon and text underneath the node. \
                     * See https://nodered.org/docs/user-guide/writing-functions for more info \
                     * @param {string} status - The status object `{fill, shape, text}` \
                     * @example `node.status({}); //clear node status` \
                     * @example `node.status({fill:"red",shape:"ring",text:"disconnected"}); //set node status to red ring with text` \
                    */ \
                    static status(status:Object); \
                } \
                declare class context { \
                    /** Get a value from context */ \
                    static get(name:String, store:String="default"); \
                    /** Store a value in context */ \
                    static set(name:String, value:Any, store:String="default"); \
                    /** Get an array of the keys in the context store */ \
                    static keys(store:String="default"):Array ; \
                } \
                declare class flow { \
                    /** Get a value from flow context */ \
                    static get(name:String, store:String="default"); \
                    /** Store a value in flow context */ \
                    static set(name:String, value:Any, store:String="default"); \
                    /** Get an array of the keys in the flow context store */ \
                    static keys(store:String="default"):Array ; \
                } \
                declare class global { \
                    /** Get a value from global context */ \
                    static get(name:String, store:String="default"); \
                    /** Store a value in global context */ \
                    static set(name:String, value:Any, store:String="default"); \
                    /** Get an array of the keys in the global context store */ \
                    static keys(store:String="default"):Array ; \
                } \
            ';

            monaco.languages.typescript.javascriptDefaults.addExtraLib(nodeLib, 'ts:filename/node.d.ts');
            monaco.languages.typescript.typescriptDefaults.addExtraLib(nodeLib, 'ts:filename/node.d.ts');
            //x monaco.languages.typescript.typescriptDefaults.addExtraLib("var Test: { x: string, y: string };");

            try {
                monaco.languages.json.jsonDefaults.setDiagnosticsOptions({ validate: true });
            } catch (error) {
                console.warn("monaco - Error setting json validate true", error)
            }
            try {
                monaco.languages.typescript.javascriptDefaults.setDiagnosticsOptions({
                    noSemanticValidation: false,
                    noSyntaxValidation: false
                });
            } catch (error) {
                console.warn("monaco - Error setting javascriptDefaults", error)
            }

            try {
                var tsOp = monaco.languages.typescript.typescriptDefaults['getCompilerOptions']();
                tsOp.allowJs = true;
                //tsOp.checkJs = true;
                //tsOp.strict = true;
            } catch (error) {
                console.warn("monaco - Error setting CompilerOptions", error)
            }

            //x window.monaco = monaco;
        }

        static getEditorSettings() {
            if (RED.settings && RED.settings.editor) {
                return RED.settings.editor;
            }
            console.log("getEditorSettings - RED.settings.editor is empty. Defaulting to MONACO");
            return {
                lib: "MONACO",
                theme: "vs"
            }; //TODO: get from runtime settings
        }
    }

    export namespace Monaco { // (this merges into the Monaco class' static scope above because it has the same name)

        export interface OnReady { (editor: MonacoEditor, currentCode: string): string };
        export interface OutputHandler { (editor: MonacoEditor, tsCode: string, compiledCode: string): void };

        export var activeEditor: monaco.editor.IStandaloneCodeEditor; // (keeps track of the most recent editor created [if ever needed])

        /** 
         * This type wraps the actual Monaco editor. 
         * Make sure RED.editor.Monaco.initialize() is called before creating editors.
         */
        export class MonacoEditor {
            private _editor: monaco.editor.IStandaloneCodeEditor;
            // private _outputEditor: monaco.editor.IStandaloneCodeEditor;
            private _tsServiceProxy: ts.IMonacoTypeScriptServiceProxy;

            __tsProxy: ts.IMonacoTypeScriptServiceProxy;

            target: HTMLElement;

            /** An optional handler to execute when ready to set the initial code for the TS editor. */
            onReady: OnReady;

            /** The target element to render the editor in for the compiled JS (usually a DIV block). */
            outputTarget: OutputHandler;

            initialCode: string;

            constructor(target: string | HTMLElement, outputTarget?: OutputHandler, onReady?: OnReady, initialCode?: string) {
                if (!target) throw "new MonacoEditor(target, outputTarget): 'target' is required (string or element value)."
                if (!outputTarget) throw "new MonacoEditor(target, outputTarget): 'outputTarget' handler is required."
                if (typeof outputTarget != 'function') throw "new MonacoEditor(target, outputTarget): 'outputTarget' is not a function."
                if (onReady && typeof onReady != 'function') throw "new MonacoEditor(target, outputTarget): 'onReady' is not a function."
                this.target = target instanceof HTMLElement ? target : document.getElementById(target);
                if (!(this.target instanceof HTMLElement)) throw "new MonacoEditor(target, outputTarget): 'target' is invalid."
                this.outputTarget = outputTarget;
                this.onReady = onReady;
                this.initialCode = initialCode && '' + initialCode || '';
            }

            private _configure(options: any) {
                console.log("MonacoEditor._configure(options) editorSettings: ", Monaco.editorSettings);
                console.log("MonacoEditor._configure(options) options: ", options);

                var createThemeMenuOption = function (theme: string) {
                    return {
                        // An unique identifier of the contributed action.
                        id: 'set-theme-' + theme,
                        // A label of the action that will be presented to the user.
                        label: 'Set theme - ' + theme,
                        precondition: <object>null,// A precondition for this action.
                        keybindingContext: <object>null,// A rule to evaluate on top of the precondition in order to dispatch the keybindings.
                        contextMenuGroupId: 'navigation',
                        contextMenuOrder: 1.5,

                        // Method that will be executed when the action is triggered.
                        // @param editor The editor instance is passed in as a convinience
                        run: function (ed: MonacoEditor): object {
                            //alert("i'm running => " + ed.getPosition());
                            monaco.editor.setTheme(theme)
                            return null;
                        }
                    }
                }

                var getMonacoLanguage = function (mode: { path: string } | string) {
                    var _mode = typeof mode == 'string' ? mode : mode?.path ?? '' + mode;
                    if (_mode)
                        _mode = _mode.replace("ace/mode/", "").replace("nrjavascript", "javascript");
                    else
                        _mode = "javascript";
                    return _mode;
                }

                // if (options.globals) {
                //     // Register the additional library.
                //     opts.globals = options.globals
                //     opts.esversion = 6
                //     opts.sub = true
                //     opts.asi = true
                //     opts.maxerr = 1000
                // }

                var editorOptions = $.extend({}, Monaco.editorSettings.options, options)
                editorOptions.language = getMonacoLanguage(options.mode);

                //apply defaults
                if (!editorOptions.minimap) {
                    editorOptions.minimap = {
                        enabled: true,
                        maxColumn: 50,
                        scale: 1,
                        showSlider: "mouseover",
                        renderCharacters: true
                    }
                }
                if (editorOptions.mouseWheelZoom == null) editorOptions.mouseWheelZoom = true;
                if (editorOptions.suggestFontSize == null) editorOptions.suggestFontSize = 12;
                if (editorOptions.formatOnPaste == null) editorOptions.formatOnPaste = true;
                if (editorOptions.foldingHighlight == null) editorOptions.foldingHighlight = true;
                if (editorOptions.foldStyle == null) editorOptions.foldStyle = true; //https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.istandaloneeditorconstructionoptions.html#folding
                if (editorOptions.readOnly == null) editorOptions.readOnly = false;
                if (editorOptions.readOnly == null) editorOptions.readOnly = false;
                if (editorOptions.lineNumbers == null) editorOptions.lineNumbers = true;
                if (editorOptions.theme == null) editorOptions.theme = monacoThemes[0];
                if (editorOptions.mode == null) editorOptions.mode = getMonacoLanguage(options.mode);

                //others
                if (!options.enableSnippets == null) editorOptions.snippetSuggestions = options.enableSnippets; //https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.istandaloneeditorconstructionoptions.html#snippetsuggestions

                if (options.foldStyle) {
                    switch (options.foldStyle) {
                        case "none":
                            editorOptions.foldStyle = false;
                            editorOptions.foldingHighlight = false
                            break;
                        default:
                            editorOptions.foldStyle = true;
                            editorOptions.foldingHighlight = true;
                            break;
                    }
                } else {
                    editorOptions.foldStyle = true;
                    editorOptions.foldingHighlight = true;
                }

                if (options.value) editorOptions.value = options.value;

                console.log("monacoOpts:", editorOptions);
            }

            private _createEditorContainer(element: HTMLElement, id: string) {
                var el = element || $("#" + id)[0];
                var toolbarRow = $("<div>").appendTo(el);
                el = $("<div>").appendTo(el).addClass("red-ui-editor-text-container")[0];
                return el;
            }

            createEditor(options: any) {
                // ... load the editors ...

                var el = this._createEditorContainer(options.element, options.id)

                console.log("initialize(): Creating the Monaco editor ...");

                activeEditor = this._editor = monaco.editor.create(this.target, {
                    automaticLayout: true, // (https://stackoverflow.com/questions/47017753/monaco-editor-dynamically-resizable)
                    value: this.initialCode || '', //[''].join('\n'),
                    language: 'typescript'
                });

                // this._outputEditor = main.editor.create(this.outputTarget, {
                //     automaticLayout: true,
                //     readOnly: true,
                //     codeLens: false,
                //     contextmenu: false,
                //     value: [
                //         '// Output JS does here ...'
                //     ].join('\n'),
                //     language: 'javascript'
                // });

                var sync = () => {
                    if (this._tsServiceProxy)
                        setTimeout(() => {
                            this._tsServiceProxy.getEmitOutput(this._editor.getModel().uri.toString())
                                .then((r) => {
                                    this.outputTarget(this, this._editor.getValue(), r.outputFiles[0].text);
                                    // console.log("Code updated: " + r.outputFiles[0].text);
                                });
                        }, 500);
                };

                this._editor.onDidChangeModelContent(sync);

                console.log("initialize(): Monaco editors created. Getting the TS worker ...");

                // ... get the typescript service ...

                monaco.languages.typescript.getTypeScriptWorker().then((workerProxy: (v: monaco.Uri) => Promise<ts.IMonacoTypeScriptServiceProxy>) => {
                    console.log("initialize(): Got the TS worker proxy. Getting the service next ...");
                    var fileUri = this._editor.getModel().uri;
                    workerProxy(fileUri).then((tsProxy) => {
                        console.log("initialize(): Got the TS worker service proxy:");
                        console.log(tsProxy);
                        this.__tsProxy = tsProxy;
                        this._tsServiceProxy = tsProxy;
                        this._tsServiceProxy.getEmitOutput(fileUri.toString()).then((r: any) => {
                            // ... execute any "ready" callbacks ...
                            // this._outputEditor.setValue(r.outputFiles[0].text);
                            this._editor.setValue(this.onReady(this, this._editor.getValue()));
                            resolve(this);
                        });
                    });
                }, (reason) => { reject("Error getting TypeScript service worker: " + reason); });
            }

            /**
             * Loads an array of library files by URL.
             */
            loadLibFiles(libFiles: string[]): void { monaco.languages.typescript.typescriptDefaults.addExtraLib("class ctx { x:0; }"); }
            loadFile(filename: string): void { /*this._tsService.loadFile(filename);*/ }
            setCode(text: string): void { /*this._tsService.setCode(text); */ }
            setOutput(text: string): void { /*this._tsService.setOutput(text);*/ }
            getCode(): string { return null; /*this._tsService.getCode();*/ }
            getOutput(): string { return null; /*this._tsService.getOutput();*/ }
        }

        var _nr_editor_init = editor.init; // (save the old reference so we can hook into it later)
        var _nr_editor_createEditor = editor.createEditor; // (save the old reference so we can hook into it later)

        editor.init = function () {
            _nr_editor_init.call(this);

            Monaco.editorSettings = this.getEditorSettings();
            Monaco.editorOptions = this.editorSettings?.options;

            console.log("editor.init() - editorSettings: ", Monaco.editorSettings);
            USE_MONACO = Monaco.editorSettings.lib === "MONACO" || false;

            if (USE_MONACO)
                Monaco.initialize();
        };
        editor.createEditor = function (options: object) {
            if (USE_MONACO)
                return new MonacoEditor(options);
            else
                return _nr_editor_createEditor.call(this, options);
        };
    }
}